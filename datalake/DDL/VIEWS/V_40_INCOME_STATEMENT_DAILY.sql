CREATE OR REPLACE VIEW `INCOME_STATEMENT_DAILY` AS 
(
	SELECT 
		t.DT,
        CASE WHEN t.DT = CURRENT_DATE() THEN "   **" ELSE "" END AS TODAY,
        CASE WHEN REVENUES+(EXPENSES+AMORTIZED_COST)+APPLICABLE_FEE > 0 THEN "UP" ELSE "DOWN" END AS EARN_FLG,
		REVENUES,
		ROUND(REVENUES+APPLICABLE_FEE,2) AVAILABLE_BUDGET,
		EXPENSES,
		SPENDING_LIMIT,
		AMORTIZED_COST,
		ROUND(COALESCE(f.FEE_AMOUNT,0),4) GENERATED_FEE,
		COALESCE(f.FEE_DUE_DATE,"") FEE_DUE_ON,
		APPLICABLE_FEE,
        ROUND((EXPENSES+AMORTIZED_COST)+APPLICABLE_FEE,2) DAILY_COST,
        ROUND(((EXPENSES+AMORTIZED_COST)+APPLICABLE_FEE)/16,2) HOURLY_COST, #16 HOURS OF AWAKE TIME
		ROUND(REVENUES+(EXPENSES+AMORTIZED_COST)+APPLICABLE_FEE,2) EARNINGS,
		ROUND(COALESCE(fo.FEES_OUTSTANDING,0)-AMORTIZED_COST-APPLICABLE_FEE,2) OUTSTANDING_FEE,
		SUM(EXPENSES+AMORTIZED_COST+APPLICABLE_FEE) OVER (PARTITION BY EXTRACT(YEAR_MONTH FROM t.DT) ORDER BY t.DT) COST_SPEED
	FROM
	(
		SELECT
			t.DT,
			REVENUES,
			SPENDING_LIMIT,
			EXPENSES,
			ABS(LEAST
			(
				0,
				EXPENSES+SPENDING_LIMIT #rev median is the spending limit
			))
			AMORTIZED_COST,
			ROUND(COALESCE(SUM(f.FEE_AMOUNT),0),4) APPLICABLE_FEE
		FROM
		(
			SELECT
				cal.DT,
				ROUND(COALESCE(rev.REV_1M,0),2) REVENUES,
				ROUND(COALESCE(SUM(t.TR_VALUE),0),2) EXPENSES,
				ROUND(COALESCE(m_rev.MEDIAN,0),2) SPENDING_LIMIT
			FROM 
            (
				SELECT * FROM CALENDAR WHERE DT <= DATE_ADD(CURRENT_DATE(), INTERVAL 7 DAY)
			) cal

			LEFT JOIN REVENUES rev
			ON cal.YEARMONTH - CASE WHEN cal.D_MONTH <> 1 THEN 1 ELSE 89 END =rev.TR_YEARMONTH
			-- payroll is payed end-of-month after expenses occurred, so month payroll can cover only next month expenses
			
			LEFT JOIN TRANSACTIONS t
			ON cal.DT=t.TR_DATE
			AND t.TR_TYPE = 'expense'

			LEFT JOIN MEDIAN_REV m_rev
			ON TRUE

			GROUP BY cal.DT
		) t
		LEFT JOIN V_SPENDING_FEES f
		ON t.DT BETWEEN f.FEE_START_DATE AND f.FEE_DUE_DATE

		GROUP BY t.DT
	) t
	LEFT JOIN V_SPENDING_FEES f
	ON t.DT=f.TR_DATE

	LEFT JOIN V_OUTSTANDING_FEES fo
	ON t.DT=fo.DT

	ORDER BY DT DESC
);